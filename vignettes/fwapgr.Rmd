---
title: "Using fwapgr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using fwapgr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(magrittr)
```

---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

The `fwapgr` package can be used to retrieve data from the BC Freshwater Atlas. In this article, we'll get stream, lake, watershed and modelled fish habitat data to create a map of the Yakoun River watershed in Haida Gwaii, BC. 

We can get started by looking at all available layers and which columns are in a specific layer.
```{r}
fwapgr::fwa_list_layers()
```

```{r}
fwapgr::fwa_list_columns('fwa_stream_networks_sp')
```

Let's use the 'fwa_stream_networks_sp' layer to get a linestring feature of the Yakoun river. The most straighforward way to retrieve data for a named stream is to filter by 'gnis_name' column. We can use `fwa_search_gnis_streams` to find a valid gnis_name. 
```{r}
print(fwapgr::fwa_search_gnis_streams("yakoun"))
```

We can then use `fwa_feature` to retrieve the stream data for 'Yakoun River'. We use the `columns` argument to include any columns along with the geometry. In this case, we'll include the `blue_line_key` column.
```{r}
yakoun <- fwapgr::fwa_feature("fwa_stream_networks_sp", 
                              filter = "gnis_name = 'Yakoun River'", 
                              columns = c("blue_line_key"))

yakoun
```

Next let's get the Yakoun River watershed. It requires a `blue_line_key`.
```{r}
blue_line_key <- unique(yakoun$blue_line_key)
wshed <- fwapgr::fwa_watershed(blue_line_key)
```

To get lake data, we will use the 'fwa_lakes_poly' layer. We can get the bounding box of the watershed data and use the `bounds` argument to only retrieve lakes within the bounds of the watershed. 
```{r}
bbox <- sf::st_bbox(wshed)
lakes <- fwapgr::fwa_feature("fwa_lakes_poly", bounds = bbox)
```

The final data we will retrieve is modelled fish habitat within our watershed bounds. Note, this is in a different schema (not the default 'whse_basemapping' schema). We'll re-classify the 'fish_habitat' column as 'fish habitat' or 'not fish habitat'. 
```{r}
habitat <- fwapgr::fwa_feature("modelled_habitat_potential", schema = 'fish_passage', columns = "fish_habitat", bounds = bbox)

habitat$habitat <- grepl('non fish habitat', habitat$fish_habitat, ignore.case = TRUE) %>%
  ifelse('not fish habitat', 'fish habitat') %>%
  factor(levels = c('not fish habitat', 'fish habitat'))
```

Finally, let's clip the habitat and lake layers to the watershed polygon to make the map look a little prettier.
```{r warning=FALSE, message=FALSE}
habitat <- sf::st_intersection(habitat, wshed)
lakes <- sf::st_intersection(lakes, wshed)
```


```{r dpi=300, fig.width=7, fig.height=7}
ggplot2::ggplot(data = yakoun) +
  ggplot2::geom_sf(data = wshed, lwd = 0.15) +
  ggplot2::geom_sf(data = habitat, ggplot2::aes(color = habitat), lwd = 0.2) +
  ggplot2::geom_sf(lwd = 0.3) +
  ggplot2::geom_sf(data = lakes, fill = "steelblue", lwd = 0.1) +
  ggplot2::theme(legend.title = ggplot2::element_blank(),
                 legend.position = "bottom")
```

